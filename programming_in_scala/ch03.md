# Next Steps in Scala

## Step 7. Parameterize arrays with types

In Scala, you can instantiate objects, or class instances, using `new`. When you instantiate an object in Scala, you can *parameterize* it with values and types. Parameterization means “configuring” an instance when you create it.

When you parameterize an instance with both a type and a value, the type comes first in its square brackets, followed by the value in parentheses.

test.scala:
```scala
val greetingStrings = new Array[String](3)
greetingStrings(0) = "Hello"
greetingStrings(1) = ", "
greetingStrings(2) = "World!\n"

for (i <- 0 to 2)
  print(greetingStrings(i))
```
```shell
$ scala test.scala
Hello, World!
```

When you define a variable with `val`, the variable can’t be reassigned, but the object to which it refers could potentially still be changed.

When you apply parentheses surrounding one or more values to a variable, Scala will transform the code into an invocation of a method named apply on that variable.
- `greetStrings(i)` ➾ `greetStrings.apply(i)`
- `1 + 2` ➾ `(1).+(2)`

Scala provides a more concise way to create and initialize ar- rays that you would normally use.
```scala
val nums1 = Array[String](3)
nums(0) = "zero"
nums(1) = "one"
nums(2) = "two"
```
```scala
val nums = Array("zero", "one", "two")
```
- it's a factory method, named `apply`, which creates and returns the new array. This `apply` method takes a variable number of arguments and is defined on the `Array` companion object.

## Step 8. Use lists

One of the big ideas of the functional style of programming is that methods should not have side effects. Another benefit (in a statically typed language) is that everything that goes into and out of a method is checked by a type checker, so logic errors are more likely to manifest themselves as type errors.

A Scala array is a mutable sequence of objects that all share the same type.
For an immutable sequence of objects that share the same type you can use Scala’s List class.
- `val oneTwoThree = List(1, 2, 3)`

```scala
val oneTwo = List(1, 2)
val threeFour = List(3, 4)
val oneTwoThreeFour = oneTwo ::: threeFour
println(oneTwo +" and "+ threeFour +" were not mutated.")
println("Thus, "+ oneTwoThreeFour +" is a new list.")
```
```scala
val twoThree = List(2, 3)
val oneTwoThree = 1 :: twoThree
println(oneTwoThree)
```
The most common operator you’ll use with lists is ‘::’, which is pronounced “cons.” Cons prepends a new element to the beginning of an existing list, and returns the resulting list.
- `::` is a method of its *right operand*, the list, twoThree.
- If the method name ends in a colon, the method is invoked on the right operand.

### Why not append to lists?
Class List does offer an `append` operation but this operation is rarely used, because the time it takes to append to a list grows linearly with the size of the list, whereas prepending with `::` takes constant time. Your options if you want to build a list efficiently by appending elements is to prepend them, then when you’re done call reverse; or use a `ListBuffer`, a mutable list that does offer an append operation, and when you’re done call `toList`.

