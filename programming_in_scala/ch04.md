# Classes and Objects

## 4.1 Classes, fields, and methods

A class is a blueprint for objects. Once you define a class, you can create objects from the class blueprint with the keyword new.

Inside a class definition, you place fields and methods, which are collectively called *members*. 
- Fields, which you define with either `val` or `var`, are variables that refer to objects. The fields hold the state, or data, of an object.
- Methods, which you define with `def`, contain executable code. The methods use that data to do the computational work of the object. 

```scala
class ChecksumAccumulator {
  private var sum = 0
  def add(b: Byte): Unit = sum += b
  def checksum(): Int = ~(sum & 0xFF) + 1
}

val acc = new ChecksumAccumulator
val csa = new ChecksumAccumulator
```

The first step is to prevent outsiders from accessing the fields directly by making the fields `private`.
- you’d say “public” in Java, you simply say nothing in Scala. Public is Scala’s default access level.

The recommended style for methods is in fact to avoid having explicit, and especially multiple, `return` statements. Instead, think of each method as an expression that yields one value, which is returned. This philosophy will encourage you to make methods quite small, to factor larger methods into multiple smaller ones.

Methods with a result type of `Unit` are executed for their *side effects*. A side effect is generally defined as mutating state somewhere external to the method or performing an I/O action.

## 4.2 Semicolon inference

In a Scala program, a semicolon at the end of a statement is usually optional. A semicolon is required if you write multiple statements on a single line.

```scala
val s = "hello"; println(s)
```

In short, a line ending is treated as a semicolon unless one of the following conditions is true:
1. The line in question ends in a word that would not be legal as the end of a statement, such as a period or an infix operator.
2. The next line begins with a word that cannot start a statement.
3. The line ends while inside parentheses `(...)` or brackets `[...]`, because these cannot contain multiple statements anyway.
4. 
```scala
  val x = 1                                       //> x  : Int = 1
  val y = 2                                       //> y  : Int = 2

  x + y                                           //> res0: Int = 3
  
  x +
    y                                             //> res1: Int = 3

  (x
    + y)                                          //> res2: Int = 3

  {
    x
    +y
  }                                               //> res3: Int = 2
```
