# For Expressions Revisited

## 23.1 For expressions
a *for* expression is of the form: *for ( seq ) yield expr*
- *seq* is a sequence of *generators*, *definitions*, and *filters*, with semicolons between successive elements. 

```scala
case class Foo(value: Int)

val foos = List(Foo(1), Foo(2), Foo(3))         //> foos  : List[myTest.Foo] = List(Foo(1), Foo(2), Foo(3))

for {
  foo <- foos                                   // a generator
  v = foo.value                                 // a definition
  if (v % 2 != 0)                               // a filter
} yield v                                       //> res0: List[Int] = List(1, 3)
```

A *generator* is of the form: *pat <- expr*
- The expression *expr* typically returns a list, even though you will see later that this can be generalized. The pattern *pat* gets matched one-by-one against all elements of that list.

A *definition* is of the form: *pat = expr*
- This definition binds the pattern *pat* to the value of *expr*. So it has the same effect as a `val` definition: `val x = expr`

A *filter* is of the form: *if expr*
Here, *expr* is an expression of type Boolean. The filter drops from the iteration all elements for which *expr* returns `false`.

## 23.2 The n-queens problem

## 23.3 Querying with for expressions

## 23.4 Translation of for expressions

## 23.5 Going the other way

## 23.6 Generalizing for

## 23.7 Conclusion
