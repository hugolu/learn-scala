# For Expressions Revisited

## 23.1 For expressions
a *for* expression is of the form: *for ( seq ) yield expr*
- *seq* is a sequence of *generators*, *definitions*, and *filters*, with semicolons between successive elements. 

```scala
case class Foo(value: Int)

val foos = List(Foo(1), Foo(2), Foo(3))         //> foos  : List[myTest.Foo] = List(Foo(1), Foo(2), Foo(3))

for {
  foo <- foos                                   // a generator
  v = foo.value                                 // a definition
  if (v % 2 != 0)                               // a filter
} yield v                                       //> res0: List[Int] = List(1, 3)
```

A *generator* is of the form: *pat <- expr*
- The expression *expr* typically returns a list, even though you will see later that this can be generalized. The pattern *pat* gets matched one-by-one against all elements of that list.

A *definition* is of the form: *pat = expr*
- This definition binds the pattern *pat* to the value of *expr*. So it has the same effect as a `val` definition: `val x = expr`

A *filter* is of the form: *if expr*
Here, *expr* is an expression of type Boolean. The filter drops from the iteration all elements for which *expr* returns `false`.

## 23.2 The n-queens problem
Given a standard chess-board, place eight queens such that no queen is in check from any other (a queen can check another piece if they are on the same column, row, or diagonal).

An imperative solution to this problem would place queens one by one, moving them around on the board. But it looks difficult to come up with a scheme that really tries all possibilities.

A more functional approach represents a solution directly, as a value. A solution consists of a list of coordinates, one for each queen placed on the board. Note, however, that a full solution can not be found in a single step. It needs to be built up gradually, by occupying successive rows with queens.
- This suggests a recursive algorithm.

```scala
def queens(n: Int): List[List[(Int, Int)]] = {
  def placeQueens(k: Int): List[List[(Int, Int)]] =
    if (k == 0)
      List(List())
    else for {
      queens <- placeQueens(k - 1)
      column <- 1 to n
      queen = (k, column)
      if isSafe(queen, queens)
    } yield queen :: queens
  placeQueens(n)
}                                               //> queens: (n: Int)List[List[(Int, Int)]]

def isSafe(queen: (Int, Int), queens: List[(Int, Int)]) =
  queens forall (q => !inCheck(queen, q))       //> isSafe: (queen: (Int, Int), queens: List[(Int, Int)])Boolean

def inCheck(q1: (Int, Int), q2: (Int, Int)) =
  q1._1 == q2._1 || // same row
  q1._2 == q2._2 || // same column
  (q1._1 - q2._1).abs == (q1._2 - q2._2).abs // on diagonal
                                                //> inCheck: (q1: (Int, Int), q2: (Int, Int))Boolean

queens(4)                                       //> res0: List[List[(Int, Int)]] = List(List((4,3), (3,1), (2,4), (1,2)), List((
                                                //| 4,2), (3,4), (2,1), (1,3)))
```
- The first generator of that for expression iterates through all solutions of placing `k - 1` queens on the board.
- The second generator iterates through all possible columns on which the kâ€™th queen might be placed.
- The third part of the for expression defines the newly considered queen position to be the pair consisting of row k and each produced column.
- The fourth part of the for expression is a filter which checks with isSafe whether the new queen is safe from check of all previous queens.
- If the new queen is not in check from any other queens, it can form part of a partial solution, so placeQueens generates with `queen :: queens` a new solution. If the new queen is not safe from check, the filter returns `false`, so no solution is generated.

## 23.3 Querying with for expressions

## 23.4 Translation of for expressions

## 23.5 Going the other way

## 23.6 Generalizing for

## 23.7 Conclusion
