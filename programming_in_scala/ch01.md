# A Scalable Language

Scala’s functional programming constructs make it easy to build interesting things quickly from simple parts. Its object-oriented constructs make it easy to structure larger systems and to adapt them to new demands. The combination of both styles in Scala makes it possible to express new kinds of programming patterns and component abstractions. It also leads to a legible and concise programming style.
 
## A language that grows on you

### Growing new types

Instead of providing all constructs you might ever need in one “perfectly complete” language, Scala puts the tools for building such constructs into your hands.

Scala allows users to grow and adapt the language in the directions they need by defining easy-to-use libraries that feel like native language support.

### Growing new control constructs

Java comes with a rich, thread-based concurrency library. Scala pro- grams can use it like any other Java API. However, Scala also offers an ad- ditional library that essentially implements Erlang’s actor model.

Actors are concurrency abstractions that can be implemented on top of threads. They communicate by sending messages to each other. An actor can perform two basic operations, message send and receive.

All in all, actors have turned out to be a very pleasant means for expressing concurrent and distributed computations. Even though they are defined in a library, actors feel like an integral part of the Scala language.

## What makes Scalas calable?

### Scala is object-oriented

The great idea of object-oriented programming is to make these containers fully general, so that they can contain operations as well as data, and that they are themselves values that can be stored in other containers, or passed as parameters to operations. Such containers are called objects.

Scala is an object-oriented language in pure form: every value is an object and every operation is a method call.

Traits are like interfaces in Java, but they can also have method implementations and even fields. Objects are constructed by mixin composition, which takes the members of a class and adds the members of a number of traits to them.
Unlike a class, a trait can add some new functionality to an unspecified superclass. This makes traits more “pluggable” than classes.

### Scala is functional

Functional programming is guided by two main ideas. The first idea is that functions are first-class values. You can pass func- tions as arguments to other functions, return them as results from functions, or store them in variables. You can also define a function inside another function, just as you can define an integer value inside a function. And you can define functions without giving them a name.

Functions that are first-class values provide a convenient means for ab- stracting over operations and creating new control structures. This generalization of functions provides great expressiveness, which often leads to very legible and concise programs.

The second main idea of functional programming is that the operations of a program should map input values to output values rather than change data in place.
Another way of stating this second idea of functional programming is that methods should not have any side effects. They should communicate with their environment only by taking arguments and returning results.

Functional languages encourage immutable data structures and referen- tially transparent methods.

## Why Scala?
## Scala’s roots
## Conclusion
