# Sequence Comprehensions

Comprehensions have the form ```for (enumerators) yield e```, where ```enumerators``` refers to a semicolon-separated list of enumerators.
  - ``` for (i <- List.range(from, to) if i % 2 == 0) yield i```

An enumerator is either a generator which introduces new variables, or it is a filter.

**A comprehension evaluates the body e** for each binding generated by the enumerators and returns a sequence of these values.

```scala
even(from: Int, to: Int): List[Int] =
  for (i <- List.range(from, to) if i % 2 == 0) yield i
//even: (from: Int, to: Int)List[Int]

scala> println(even(0, 20))
//List(0, 2, 4, 6, 8, 10, 12, 14, 16, 18)
```

補充：[scala学习笔记(3) -- for comprehension](http://fakechris.iteye.com/blog/107097)
scala并不支持一般的for循环，取而代之的是for comprehesion。scala通过丰富的for comprehesion特性支持各种循环结构。
要使一个类支持for comprehesion很简单，不需要继承任何trait，相应的实现map, filter, flatMap, foreach四个方法中的一个或多个即可。
```scala
val list = List(1,2,3)

list.map(p => 2*p)
for(p <- list) yeild 2*p
//List[Int] = List(2, 4, 6)

list.foreach(p => print(p))
for(p <- list) print(p)
//123

list.filter(p => p%2!=0)
for(p <- list if p%2!=0) yield p
//List[Int] = List(1, 3)

list.flatMap(p => for(pp <- list2) yield p*pp)
for(p <- list; pp <- list2) yield p*pp
//List[Int] = List(4, 5, 6, 8, 10, 12, 12, 15, 18)
```

## A more complicated example 
```scala
def foo(n: Int, v: Int) = for (i <- 0 until n; j <- i until n if i + j == v) yield Pair(i, j)
foo(20, 32)foreach(println)
//(13,19)
//(14,18)
//(15,17)
//(16,16)

def bar(n: Int, v: Int) = for (i <- Range(0,n); j <- Range(i, n) if i + j == v) yield(i,j)
bar(20, 32).foreach(println)
//(13,19)
//(14,18)
//(15,17)
//(16,16)
```
-  comprehensions are not restricted to lists
